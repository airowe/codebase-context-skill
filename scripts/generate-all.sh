#!/bin/bash
# Generate all codebase context files
# Usage: ./generate-all.sh [project-root]
#
# This script generates:
# - code-index.json     (lightweight search index)
# - deps.mermaid        (dependency graph in Mermaid)
# - deps.json           (dependency graph as JSON)
#
# For the full codebase-context.md, use the Claude Code skill.

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${1:-.}"
OUTPUT_DIR="$PROJECT_ROOT/.claude"

mkdir -p "$OUTPUT_DIR"

echo "========================================"
echo "Codebase Context Generator"
echo "========================================"
echo ""
echo "Project: $PROJECT_ROOT"
echo "Output:  $OUTPUT_DIR"
echo ""

# Check for optional tools
HAS_MADGE=false
HAS_DEPCRUISE=false

if command -v npx &> /dev/null; then
    if npx madge --version &> /dev/null 2>&1; then
        HAS_MADGE=true
    fi
    if npx depcruise --version &> /dev/null 2>&1; then
        HAS_DEPCRUISE=true
    fi
fi

# ============================================================================
# Generate code-index.json
# ============================================================================

echo "Step 1: Generating code-index.json"
echo "-----------------------------------"
bash "$SCRIPT_DIR/generate-code-index.sh" "$PROJECT_ROOT"
echo ""

# ============================================================================
# Generate dependency graph
# ============================================================================

echo "Step 2: Generating dependency graph"
echo "-----------------------------------"

# Detect if this is a Node.js project
if [ -f "$PROJECT_ROOT/package.json" ]; then
    # Prefer madge if available (more accurate for JS/TS)
    if [ "$HAS_MADGE" = true ]; then
        echo "Using madge for accurate TypeScript/JavaScript dependencies..."

        # Find entry point
        ENTRY=""
        for candidate in "src/index.ts" "src/index.tsx" "src/main.ts" "src/app.ts" "index.ts" "src/index.js" "index.js"; do
            if [ -f "$PROJECT_ROOT/$candidate" ]; then
                ENTRY="$candidate"
                break
            fi
        done

        if [ -n "$ENTRY" ]; then
            echo "Entry point: $ENTRY"

            # Generate JSON (most useful for agents)
            npx madge --json "$PROJECT_ROOT/$ENTRY" > "$OUTPUT_DIR/deps.json" 2>/dev/null || true

            # Generate DOT for visualization
            npx madge --dot "$PROJECT_ROOT/$ENTRY" > "$OUTPUT_DIR/deps.dot" 2>/dev/null || true

            # Convert to Mermaid (simplified)
            if [ -f "$OUTPUT_DIR/deps.json" ]; then
                echo "Converting to Mermaid format..."
                echo "%% Dependency Graph (generated by madge)" > "$OUTPUT_DIR/deps.mermaid"
                echo "graph LR" >> "$OUTPUT_DIR/deps.mermaid"

                # Parse JSON and create Mermaid edges
                # This is a simple jq-less approach
                grep -oE '"[^"]+": \[' "$OUTPUT_DIR/deps.json" | while read -r line; do
                    local from=$(echo "$line" | grep -oE '"[^"]+"' | tr -d '"')
                    local from_id=$(echo "$from" | sed 's/[^a-zA-Z0-9]/_/g')
                    local from_label=$(basename "$from" | sed 's/\.[^.]*$//')

                    # This is incomplete - full parsing would need jq
                    # For now, just note the file exists
                    echo "  ${from_id}[\"$from_label\"]" >> "$OUTPUT_DIR/deps.mermaid"
                done
            fi
        else
            echo "No entry point found, using fallback script..."
            bash "$SCRIPT_DIR/generate-deps.sh" "$PROJECT_ROOT" "mermaid"
            bash "$SCRIPT_DIR/generate-deps.sh" "$PROJECT_ROOT" "json"
        fi
    else
        echo "madge not found, using fallback script..."
        echo "(Install with: npm install -g madge)"
        bash "$SCRIPT_DIR/generate-deps.sh" "$PROJECT_ROOT" "mermaid"
        bash "$SCRIPT_DIR/generate-deps.sh" "$PROJECT_ROOT" "json"
    fi
else
    # Non-Node project, use our scripts
    bash "$SCRIPT_DIR/generate-deps.sh" "$PROJECT_ROOT" "mermaid"
    bash "$SCRIPT_DIR/generate-deps.sh" "$PROJECT_ROOT" "json"
fi

echo ""

# ============================================================================
# Generate snapshot for freshness detection
# ============================================================================

echo "Step 3: Updating freshness snapshot"
echo "-----------------------------------"

SNAPSHOT_FILE="$OUTPUT_DIR/codebase-context.snapshot"

# Directory tree hash
TREE_HASH=$(find "$PROJECT_ROOT" -maxdepth 3 -type d \
    -not -path '*/\.*' \
    -not -path '*/node_modules*' \
    -not -path '*/dist*' \
    -not -path '*/build*' \
    -not -path '*/.next*' \
    -not -path '*/__pycache__*' \
    -not -path '*/target*' \
    2>/dev/null | sort | md5sum 2>/dev/null | cut -d' ' -f1 || md5 -q 2>/dev/null)

echo "tree: $TREE_HASH" > "$SNAPSHOT_FILE"
echo "generated: $(date +%s)" >> "$SNAPSHOT_FILE"

# Hash key config files
for CONFIG in package.json tsconfig.json pyproject.toml Cargo.toml go.mod; do
    if [ -f "$PROJECT_ROOT/$CONFIG" ]; then
        HASH=$(md5sum "$PROJECT_ROOT/$CONFIG" 2>/dev/null | cut -d' ' -f1 || md5 -q "$PROJECT_ROOT/$CONFIG" 2>/dev/null)
        echo "$CONFIG: $HASH" >> "$SNAPSHOT_FILE"
    fi
done

echo "Snapshot saved to $SNAPSHOT_FILE"
echo ""

# ============================================================================
# Summary
# ============================================================================

echo "========================================"
echo "Generation Complete!"
echo "========================================"
echo ""
echo "Generated files:"
ls -la "$OUTPUT_DIR"/*.json "$OUTPUT_DIR"/*.mermaid "$OUTPUT_DIR"/*.dot "$OUTPUT_DIR"/*.snapshot 2>/dev/null | awk '{print "  " $NF " (" $5 " bytes)"}'
echo ""
echo "Next steps:"
echo "  1. Review the generated files"
echo "  2. Run /skill codebase-context to generate codebase-context.md"
echo "  3. Commit all files in .claude/ to version control"
echo ""
